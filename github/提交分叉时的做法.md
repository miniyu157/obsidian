假设上次拉取后, 远程又创建了新的提交, 所以本地推送失败

#### 先看看怎么回事

先拉取远程的最新信息, 不合并

```bash
git fetch
```

查看远程比你多了什么

```bash
git log HEAD..origin/main
```

查看你比远程多了什么

```bash
git log origin/main..HEAD
```

图形化查看分叉

```bash
git log --graph --oneline --decorate main origin/main
```

效果类似

```bash
╰─ git log --graph --oneline --decorate main origin/main
* f52d87d (HEAD -> main) 📄 添加 README.md
| * 08e0a2e (origin/main, origin/HEAD) 📄 添加 README.md
|/  
* 79fed05 📁 漏掉了 .idea
* 48238fa 🎓 1.牛刀小试 learn rust!
```
#### 解决它

选项一. 将远程的变更合并到你本地，然后再 push, 效果是产生一个合并提交

```bash
git pull
```

选项二. 或者先拉取远程的提交, 然后把本地提交放到最上面, 这样做不会在提交记录中显示分叉

```bash
git pull --rebase
```

> 如果远程和本地修改了同一个文件的同一行, 则需要手动解决冲突

选项三. 强制推送, 这会覆盖远程的提交, 不推荐

```bash
git push --force # 或者简写为 -f
```

